#!/usr/bin/env ruby

require "optparse"

def asciidoc_extract_options(file)
  header = file.sub(/\n\n.*$/m, "")
  /\nscript: (?<script>[^\n]+)\n/ =~ header
  /\nbody-font: (?<bodyfont>[^\n]+)\n/ =~ header
  /\nheader-font: (?<headerfont>[^\n]+)\n/ =~ header
  /\nmonospace-font: (?<monospacefont>[^\n]+)\n/ =~ header
  /\ntitle-font: (?<titlefont>[^\n]+)\n/ =~ header
  /\ni18nyaml: (?<ni18nyaml>[^\n]+)\n/ =~ header
  {
    script: defined?(script) ? script : nil,
    bodyfont: defined?(bodyfont) ? bodyfont : nil,
    headerfont: defined?(headerfont) ? headerfont : nil,
    monospacefont: defined?(monospacefont) ? monospacefont : nil,
    titlefont: defined?(titlefont) ? titlefont : nil,
    i18nyaml: defined?(i18nyaml) ? i18nyaml : nil,
  }.reject { |_, val| val.nil? }.map
end

def pdf_convert(filename)
  url = "#{Dir.pwd}/#{filename}.html"
  pdfjs = File.join(File.dirname(__FILE__), 'pdf.js')
  system "export NODE_PATH=$(npm root --quiet -g);
                node #{pdfjs} file://#{url} #{filename}.pdf"
end


supported_backends = [
  {
    short: :rfc2,
    load_path: "asciidoctor/rfc/v2/converter",
    asciidoctor_backend: "rfc2"
  },

  {
    short: :rfc3,
    load_path: "asciidoctor/rfc/v3/converter",
    asciidoctor_backend: "rfc3"
  },

  {
    short: :iso,
    load_path: "asciidoctor/iso/converter",
    asciidoctor_backend: "iso"
  },

  {
    short: :gb,
    load_path: "asciidoctor/gb/converter",
    asciidoctor_backend: "gb"
  },

  {
    short: :csd,
    load_path: "asciidoctor/csd/converter",
    asciidoctor_backend: "csd"
  },

  {
    short: :csand,
    load_path: "asciidoctor/csand/converter",
    asciidoctor_backend: "csand"
  },

  {
    short: :m3d,
    load_path: "asciidoctor/m3d/converter",
    asciidoctor_backend: "m3d"
  },

  {
    short: :rsd,
    load_path: "asciidoctor/rsd/converter",
    asciidoctor_backend: "rsd"
  },
]

print "[metanorma] detecting backends: "
backends_enabled, backends_disabled = supported_backends.partition do |backend|
  begin
    print "#{backend[:short]} "
    require backend[:load_path]
    true
  rescue LoadError
    # puts "[metanorma] backend #{backend[:short]} not present"
    false
  end
end
puts

options = {
  format: "asciidoc"
}

backend_keys = backends_enabled.map {|b| b[:short].to_s }

opt_parser = OptionParser.new do |opts|
  opts.banner += " <file>"

  opts.on(
    '-v',
    '--version',
    "Print version of code",
  ) { options[:version] = true }

  opts.on(
    '-t',
    '--type TYPE',
    "Type of standard to generate: #{backend_keys.join(", ")}"
  ) { |v| options[:type] = v }

  opts.on(
    '-f',
    '--format FORMAT',
    'Format of source file: asciidoc (current default, only format supported)'
  ) { |v| options[:format] = v }

  opts.on(
    '-o',
    '--output FILENAME',
    'XML output file'
  ) { |v| options[:xml] = v }

  opts.on(
    '-h',
    '--output-html FILENAME',
    'HTML output file'
  ) { |v| options[:html] = v }

  opts.on(
    '-p',
    '--output-pdf FILENAME',
    'HTML output file'
  ) { |v| options[:pdf] = v }

  opts.on(
    '-w',
    '--output-word FILENAME',
    'Word output file'
  ) { |v| options[:word] = v }

  opts.on(
    '-r',
    '--require LIBRARY',
    'Require LIBRARY prior to execution'
  ) { |v|
    options[:require] ||= []
    options[:require] << v
  }

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end

end

# if specify output format of HTML, Word, PDF, exclude unspecified others
if options[:html] || options[:word] || options[:pdf]
  suppress_html = true unless options[:html]
  suppress_word = true unless options[:word]
  suppress_pdf = true unless options[:pdf]
end

opt_parser.parse!(ARGV)
options[:filename] = ARGV.pop

unless options[:type]
  puts "[metanorma] Error: Please specify a standard type."
  puts opt_parser.help
  exit 0
end

unless backend_keys.include? options[:type]
  puts "[metanorma] Error: #{options[:type]} is not a supported standard type."
  exit 0
end

unless options[:format] == "asciidoc"
  puts "[metanorma] Error: Only source file format currently supported is 'asciidoc'."
  exit 0
end

if options[:version]
  case options[:type]
  when "iso"
    puts "Asciidoctor::ISO #{Asciidoctor::ISO::VERSION}/IsoDoc #{IsoDoc::VERSION}"
  when "gb"
    puts "Asciidoctor::Gb #{Asciidoctor::Gb::VERSION}"
  when "csd"
    puts "Asciidoctor::Csd #{Asciidoctor::Csd::VERSION}"
  when "csand"
    puts "Asciidoctor::Csand #{Asciidoctor::Csand::VERSION}"
  when "m3d"
    puts "Asciidoctor::M3d #{Asciidoctor::M3d::VERSION}"
  when "rsd"
    puts "Asciidoctor::Rsd #{Asciidoctor::Rsd::VERSION}"
  end
  exit
end

unless options[:filename]
  puts "[metanorma] Error: Need to specify a file to process."
  exit 0
end

if options[:require]
  options[:require].each do |r|
    require r
  end
end

case options[:format]
when "asciidoc"
  if %w{rfc2 rfc3}.include? options[:type]
    Asciidoctor.convert_file options[:filename], to_file: true, safe: :safe, backend: options[:type], header_footer: true
  else
    file = File.read(options[:filename], encoding: "utf-8")
    #file = file.sub(%r{^([^\n]*\n)}, "\\1:nodoc: \n") # no isodoc output; ignored in rfc2, rfc3
    xml = Asciidoctor.convert file, to_file: false, safe: :safe, backend: options[:type], header_footer: true,
      attributes: %w(nodoc stem xrefstyle=short)

    if options[:xml]
      File.open(options[:xml], "w:UTF-8") { |file| file.write(xml) }
    end

    isodoc_options = asciidoc_extract_options(file)
    filename = options[:filename].sub(/\.[^.]+$/, "")
    case options[:type]
    when "iso"
      IsoDoc::Iso::Convert.new(options).convert(filename, xml) unless suppress_html
      IsoDoc::Iso::Convert.new(options.merge(alt: true)).convert(filename + "_alt", xml) unless suppress_html
      IsoDoc::Iso::WordConvert.new(options).convert(filename, xml) unless suppress_word
    when "gb"
      IsoDoc::Gb::Convert.new(options).convert(filename, xml) unless suppress_html
      IsoDoc::Gb::WordConvert.new(options).convert(filename, xml) unless suppress_word
    when "csd"
      IsoDoc::Csd::Convert.new(options).convert(filename, xml) unless suppress_html
      pdf_convert(filename) unless suppress_pdf
    when "csand"
      IsoDoc::Csand::Convert.new(options).convert(filename, xml) unless suppress_html
    when "m3d"
      IsoDoc::M3d::Convert.new(options).convert(filename, xml) unless supress_html
      IsoDoc::M3d::WordConvert.new(options).convert(filename, xml) unless supress_word
    when "rsd"
      IsoDoc::Rsd::Convert.new(options).convert(filename, xml) unless supress_html
      IsoDoc::Rsd::WordConvert.new(options).convert(filename, xml) unless supress_word
    end
  end
end

